提供服务 : 添加目录。


打个比方，一个县有三个社区（server）, 每个社区都有一个自己的居委会(raft)， 负责商议各项提案（request）是否执行。
现在这个县收到一个上级(client)的提案(request)。由master居委会(master raft)所在的社区接收这个提案，
居委会将其记录在案（log），然后组织三个居委会开始讨论商议（appendentry）,只要两个及以上的居委会表示赞成，
那么这个县就决定执行这个提案，但是决议不代表这个事就完成了，还要发动社区的人去做事的（commit != execute）。
为了号召相应社区的群众去完成这个提案，必须在社区公告上对该提案进行公示通知（记录commitIndex），
意思说群众们，咱们社区又有事要干了。但是完成事情是要时间的，
社区(server)只能按照公告栏上提案被公示的时间顺序（commitIndex表示的是最后公示的提案）
来一件一件完成相应的提案（lastApplied的表示这个社区刚做完的提案）。
所以一个关系是，社区做完的事永远慢于社区需要做的事（lastApplied <= commitIndex）。
只有等社区完成了（而不是仅仅通过了）这个提案，上级才能看的到。

// 宕机不超过一半就能继续工作,宕机如若超过一半,则可能丢失日志。。
只有超过一半服务器拥有某条日志,日志才能成功提交。

选举限制 :
    raft通过投票过程来阻止不合理的候选人赢得选举,除非该候选人拥有其日志中包含所有已提交的条目。
    在原有的选举机制上,如若原来会支持的,要加上条件 : 在其他条件满足的前提下,如若对方日志索引比我小,或者日志索引等于我并且上一次日志任期等于我就投支持票

    请求投票 :
        根据上一次日志索引(lastLogIndex)和上一次日志任期数(lastLogTerm)来判断是否能获得大多数支持。
        在其他投票条件满足的前提下,如若对方日志索引比我小,或者日志索引等于我并且上一次日志任期等于我就投支持票
    领导者 :
        term 4
        prevIndex 2
        prevTerm 3
        entries [4]
        commitIndex 2

内部实现 :
小细节 :
    追加日志条目的rpc有两个功能 : 
        1) 追加日志条目
        2) 作为心跳包(当日志条目没有日志时)
    日志条目也有 term
    目录条目是一条一条追加的(即使对方有多条没有)。
日志条目状态 :
    已提交 : 表示有大多数追随者都已经添加成功(如何算添加成功？)


    在什么情况下发送日志条目?
        在上一次心跳发送返回是 true 并且当前还有日志条目未更新的时候。

        成为领导第一步 : 将matchIndex都置为0,nextIndex都置为lastIndex + 1
        发送 nextIndex[i] - 1 作为lastlogIndex
        获取返回值,matchIndex(只有对上了返回true才有效,用来确认没对错),

        如若返回结果为false,则nextIndex[i]--继续发送。
        对了之后设置matchIndex


策略 :
    接受命令的过程 :
        领导者接受客户端请求；
        领导者把指令追加到日志；
        发送AppendEntries RPC到追随者；
        领导者收到大多数追随者的确认后，领导者Commit该日志，把日志在状态机中回放，并返回结果给客户端;

    提交过程 :
        在下一个心跳阶段，领导者再次发送AppendEntries RPC给追随者，日志已经commited；
        追随者收到Commited日志后，将日志在状态机中回放。


    只要一条日志大多数都持久化了,那么怎么都不会丢失日志。
        原理在于 :
            假设这些持久化了这条日志的raft都挂了,那么剩下的小部分不可能选出领导者来。
            无领导者也不会存在客户端提交新日志的可能,只有当某一个持久化了这条日志的raft重启后,才可能选出新的领导者。

    如果leader已经将日志发送给一半以上的节点后，没回复客户端就宕机了，该如何处理？
        假定不用raft，数据库客户端发送数据库更新操作后，服务器侧接收并提交更新，但未返回客户端响应前，网络断了，客户端是当成功还是失败呢？

        跟raft关系不大，分布式系统通信不可靠的问题。
        更普遍的情况是客户端请求服务端，请求超时，此时客户端不知道请求是否成功执行。
        一般的做法是把错误继续往上抛，让终端用户重试，重试时需要有相应的防止重复的机制，
        比如先拿一个id，后续请求都关联这个id实现幂等。

        由客户端查询是否提交成功。。如若成功则不重试,如若不成功,则重试。

    如果leader还未提交给一半以上节点,

关于幂等性 :
    就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，
    不会因为多次点击而产生了副作用。
    举个最简单的例子，那就是支付，用户购买商品使用约支付，支付扣款成功，
    但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，
    此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，
    流水记录也变成了两条．．．

    客户端生成一个编号,然后发送给服务器。服务器会记下该客户端的最后一个编号。
    客户端