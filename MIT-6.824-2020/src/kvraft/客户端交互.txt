Raft的目标是实现可线性化的语义（每个操作似乎在调用和响应之间的某个时刻立即执行一次，恰好一次）。
但是，到目前为止，Raft可以多次执行命令：
例如，如果领导者在提交日志条目之后但在响应客户端之前崩溃，
则客户端将使用新的领导者重试该命令，从而导致第二次执行。
该解决方案是让客户端为每个命令分配唯一的序列号。
然后，状态机将跟踪为每个客户端处理的最新序列号以及相关的响应。
如果收到序列号已执行的命令，则立即响应，而无需重新执行请求。


线性化语义 :

clients 如何找到 raft leader?
    首先随机查看一个raft是否是领导者
    如果客户机的第一选择不是领导者，服务器将拒绝客户机的请求，并提供有关其最近听到的领导者的信息（请求包括领导者的网络地址）。
    如果leader崩溃，客户端请求将超时；然后客户端使用随机选择的服务器重试。

当某个领导者接受到一条日志请求时,在没有返回结果之前崩溃了,当前客户端无法得知执行结果。
    1) 提交日志请求的时候leader会返回一个序列号给客户端。
    2) 如若领导者崩溃了,并且没有返回结果给客户端,客户端会请求新的领导者。
    3) 请求到达新的领导者的时候,新的领导者根据请求携带的序列号判断是直接返回结果还是执行。

初始时,网络正常,且有领导者,忽然大多数追随者 与 少部分追随者+领导者 分为了两个网络模块, 此时会形成同一个网络具有两个领导者的局面。
    对于写日志而言,如若请求了 少部分追随者+领导者 这个网络模块,无法得到请求成功的结果,影响不算很大。
    对于读日志而言,如若请求了 少部分追随者+领导者 这个网络模块, 需要领导者先验证一下自己是否是真正的领导者 ,否则可能读取到旧数据。

单写多读 :
    读任务分配给拥有最新提交的追随者,每次读只需要判断提交(或追加)日志是否是最新的,如若是则可读。



